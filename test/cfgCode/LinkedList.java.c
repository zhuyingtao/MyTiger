// This is automatically generated by the Tiger compiler.
// Do NOT modify!

// Control-flow Graph

// structures
struct LinkedList
{
  struct LinkedList_vtable *vptr;
};
struct Element
{
  struct Element_vtable *vptr;
  int Age;
  int Salary;
  int Married;
};
struct List
{
  struct List_vtable *vptr;
  struct Element * elem;
  struct List * next;
  int end;
};
struct LL
{
  struct LL_vtable *vptr;
};
// vtables structures
struct LinkedList_vtable
{
};

struct Element_vtable
{
  int (*Init)();
  int (*GetAge)();
  int (*GetSalary)();
  int (*GetMarried)();
  int (*Equal)();
  int (*Compare)();
};

struct List_vtable
{
  int (*Init)();
  int (*InitNew)();
  struct List * (*Insert)();
  int (*SetNext)();
  struct List * (*Delete)();
  int (*Search)();
  int (*GetEnd)();
  struct Element * (*GetElem)();
  struct List * (*GetNext)();
  int (*Print)();
};

struct LL_vtable
{
  int (*Start)();
};


// vtables declared
struct LinkedList_vtable LinkedList_vtable_ ;
struct Element_vtable Element_vtable_ ;
struct List_vtable List_vtable_ ;
struct LL_vtable LL_vtable_ ;

// methods
int Element_Init(struct Element * this, int v_Age, int v_Salary, int v_Married)
{

L_0:
  this->Age = v_Age;
  this->Salary = v_Salary;
  this->Married = v_Married;
  return 1;
}
int Element_GetAge(struct Element * this)
{

L_1:
  return this->Age;
}
int Element_GetSalary(struct Element * this)
{

L_2:
  return this->Salary;
}
int Element_GetMarried(struct Element * this)
{

L_3:
  return this->Married;
}
int Element_Equal(struct Element * this, struct Element * other)
{
  int ret_val;
  int aux01;
  int aux02;
  int nt;
  struct Element * x_1;
  struct Element * x_2;
  struct Element * x_3;
  struct Element * x_4;
  struct Element * x_5;
  struct Element * x_6;
  int x_45;
  int x_46;
  int x_47;
  int x_48;
  int x_49;
  int x_50;
  int x_51;
  int x_52;
  int x_53;

L_4:
  ret_val = 1;
  x_45 = other->vptr->GetAge(other);
  aux01 = x_45;
  x_47 = this->vptr->Compare(this, aux01, this->Age);
  x_46 = !(x_47);
  if (x_46)
    goto L_5;
  else
    goto L_6;
L_6:
  x_48 = other->vptr->GetSalary(other);
  aux02 = x_48;
  x_50 = this->vptr->Compare(this, aux02, this->Salary);
  x_49 = !(x_50);
  if (x_49)
    goto L_8;
  else
    goto L_9;
L_9:
  if (this->Married)
    goto L_11;
  else
    goto L_12;
L_12:
  x_51 = other->vptr->GetMarried(other);
  if (x_51)
    goto L_14;
  else
    goto L_15;
L_15:
  nt = 0;
  goto L_16;
L_14:
  ret_val = 0;
  goto L_16;
L_16:
  goto L_13;
L_11:
  x_53 = other->vptr->GetMarried(other);
  x_52 = !(x_53);
  if (x_52)
    goto L_17;
  else
    goto L_18;
L_18:
  nt = 0;
  goto L_19;
L_17:
  ret_val = 0;
  goto L_19;
L_19:
  goto L_13;
L_13:
  goto L_10;
L_8:
  ret_val = 0;
  goto L_10;
L_10:

  goto L_7;
L_5:
  ret_val = 0;
  goto L_7;
L_7:
  return ret_val;
}
int Element_Compare(struct Element * this, int num1, int num2)
{
  int retval;
  int aux02;
  int x_54;
  int x_55;
  int x_56;
  int x_57;

L_20:
  retval = 0;
  x_54 = num2 + 1;
  aux02 = x_54;
  x_55 = num1 < num2;
  if (x_55)
    goto L_21;
  else
    goto L_22;
L_22:
  x_57 = num1 < aux02;
  x_56 = !(x_57);
  if (x_56)
    goto L_24;
  else
    goto L_25;
L_25:
  retval = 1;
  goto L_26;
L_24:
  retval = 0;
  goto L_26;
L_26:
  goto L_23;
L_21:
  retval = 0;
  goto L_23;
L_23:
  return retval;
}
int List_Init(struct List * this)
{

L_27:
  this->end = 1;
  return 1;
}
int List_InitNew(struct List * this, struct Element * v_elem, struct List * v_next, int v_end)
{

L_28:
  this->end = v_end;
  this->elem = v_elem;
  this->next = v_next;
  return 1;
}
struct List * List_Insert(struct List * this, struct Element * new_elem)
{
  int ret_val;
  struct List * aux03;
  struct List * aux02;
  struct List * x_7;
  struct List * x_58;
  int x_59;

L_29:
  aux03 = this;
  x_58 = ((struct List*)(Tiger_new (&List_vtable_, sizeof(struct List))));
  aux02 = x_58;
  x_59 = aux02->vptr->InitNew(aux02, new_elem, aux03, 0);
  ret_val = x_59;
  return aux02;
}
int List_SetNext(struct List * this, struct List * v_next)
{

L_30:
  this->next = v_next;
  return 1;
}
struct List * List_Delete(struct List * this, struct Element * e)
{
  struct List * my_head;
  int ret_val;
  int aux05;
  struct List * aux01;
  struct List * prev01;
  int var_end;
  struct Element * var_elem;
  int aux04;
  int nt;
  struct Element * x_8;
  struct List * x_9;
  struct List * x_10;
  struct List * x_11;
  struct List * x_12;
  struct List * x_13;
  struct List * x_14;
  int x_60;
  int x_61;
  int x_62;
  int x_63;
  int x_64;
  int x_65;
  struct List * x_66;
  struct List * x_67;
  int x_68;
  struct List * x_69;
  int x_70;
  struct Element * x_71;

L_31:
  my_head = this;
  ret_val = 0;
  aux04 = -1;
  aux01 = this;
  prev01 = this;
  var_end = this->end;
  var_elem = this->elem;
  goto L_32;
L_32:
  x_61 = !(var_end);
  x_62 = !(ret_val);
  x_60 = x_61 && x_62;
  if (x_60)
    goto L_33;
  else
    goto L_34;
L_33:
  x_63 = e->vptr->Equal(e, var_elem);
  if (x_63)
    goto L_35;
  else
    goto L_36;
L_36:
  nt = 0;
  goto L_37;
L_35:
  ret_val = 1;
  x_64 = aux04 < 0;
  if (x_64)
    goto L_38;
  else
    goto L_39;
L_39:
  System_out_println (-555);
  x_66 = aux01->vptr->GetNext(aux01);
  x_65 = prev01->vptr->SetNext(prev01, x_66);
  aux05 = x_65;
  System_out_println (-555);

  goto L_40;
L_38:
  x_67 = aux01->vptr->GetNext(aux01);
  my_head = x_67;

  goto L_40;
L_40:

  goto L_37;
L_37:
  x_68 = !(ret_val);
  if (x_68)
    goto L_41;
  else
    goto L_42;
L_42:
  nt = 0;
  goto L_43;
L_41:
  prev01 = aux01;
  x_69 = aux01->vptr->GetNext(aux01);
  aux01 = x_69;
  x_70 = aux01->vptr->GetEnd(aux01);
  var_end = x_70;
  x_71 = aux01->vptr->GetElem(aux01);
  var_elem = x_71;
  aux04 = 1;

  goto L_43;
L_43:

  goto L_32;
L_34:
  return my_head;
}
int List_Search(struct List * this, struct Element * e)
{
  int int_ret_val;
  struct List * aux01;
  struct Element * var_elem;
  int var_end;
  int nt;
  struct Element * x_15;
  struct List * x_16;
  struct List * x_17;
  struct List * x_18;
  int x_72;
  int x_73;
  struct List * x_74;
  int x_75;
  struct Element * x_76;

L_44:
  int_ret_val = 0;
  aux01 = this;
  var_end = this->end;
  var_elem = this->elem;
  goto L_45;
L_45:
  x_72 = !(var_end);
  if (x_72)
    goto L_46;
  else
    goto L_47;
L_46:
  x_73 = e->vptr->Equal(e, var_elem);
  if (x_73)
    goto L_48;
  else
    goto L_49;
L_49:
  nt = 0;
  goto L_50;
L_48:
  int_ret_val = 1;

  goto L_50;
L_50:
  x_74 = aux01->vptr->GetNext(aux01);
  aux01 = x_74;
  x_75 = aux01->vptr->GetEnd(aux01);
  var_end = x_75;
  x_76 = aux01->vptr->GetElem(aux01);
  var_elem = x_76;

  goto L_45;
L_47:
  return int_ret_val;
}
int List_GetEnd(struct List * this)
{

L_51:
  return this->end;
}
struct Element * List_GetElem(struct List * this)
{

L_52:
  return this->elem;
}
struct List * List_GetNext(struct List * this)
{

L_53:
  return this->next;
}
int List_Print(struct List * this)
{
  struct List * aux01;
  int var_end;
  struct Element * var_elem;
  struct Element * x_19;
  struct List * x_20;
  struct List * x_21;
  struct List * x_22;
  int x_77;
  int x_78;
  struct List * x_79;
  int x_80;
  struct Element * x_81;

L_54:
  aux01 = this;
  var_end = this->end;
  var_elem = this->elem;
  goto L_55;
L_55:
  x_77 = !(var_end);
  if (x_77)
    goto L_56;
  else
    goto L_57;
L_56:
  x_78 = var_elem->vptr->GetAge(var_elem);
  System_out_println (x_78);
  x_79 = aux01->vptr->GetNext(aux01);
  aux01 = x_79;
  x_80 = aux01->vptr->GetEnd(aux01);
  var_end = x_80;
  x_81 = aux01->vptr->GetElem(aux01);
  var_elem = x_81;

  goto L_55;
L_57:
  return 1;
}
int LL_Start(struct LL * this)
{
  struct List * head;
  struct List * last_elem;
  int aux01;
  struct Element * el01;
  struct Element * el02;
  struct Element * el03;
  struct List * x_23;
  struct List * x_24;
  struct List * x_25;
  struct Element * x_26;
  struct List * x_27;
  struct List * x_28;
  struct Element * x_29;
  struct List * x_30;
  struct List * x_31;
  struct Element * x_32;
  struct List * x_33;
  struct List * x_34;
  struct Element * x_35;
  struct List * x_36;
  struct List * x_37;
  struct Element * x_38;
  struct List * x_39;
  struct List * x_40;
  struct List * x_41;
  struct List * x_42;
  struct List * x_43;
  struct List * x_44;
  struct List * x_82;
  int x_83;
  int x_84;
  int x_85;
  struct Element * x_86;
  int x_87;
  struct List * x_88;
  int x_89;
  struct Element * x_90;
  int x_91;
  struct List * x_92;
  int x_93;
  struct Element * x_94;
  int x_95;
  struct List * x_96;
  int x_97;
  struct Element * x_98;
  int x_99;
  int x_100;
  int x_101;
  struct Element * x_102;
  int x_103;
  struct List * x_104;
  int x_105;
  struct List * x_106;
  int x_107;
  struct List * x_108;
  int x_109;

L_58:
  x_82 = ((struct List*)(Tiger_new (&List_vtable_, sizeof(struct List))));
  last_elem = x_82;
  x_83 = last_elem->vptr->Init(last_elem);
  aux01 = x_83;
  head = last_elem;
  x_84 = head->vptr->Init(head);
  aux01 = x_84;
  x_85 = head->vptr->Print(head);
  aux01 = x_85;
  x_86 = ((struct Element*)(Tiger_new (&Element_vtable_, sizeof(struct Element))));
  el01 = x_86;
  x_87 = el01->vptr->Init(el01, 25, 37000, 0);
  aux01 = x_87;
  x_88 = head->vptr->Insert(head, el01);
  head = x_88;
  x_89 = head->vptr->Print(head);
  aux01 = x_89;
  System_out_println (10000000);
  x_90 = ((struct Element*)(Tiger_new (&Element_vtable_, sizeof(struct Element))));
  el01 = x_90;
  x_91 = el01->vptr->Init(el01, 39, 42000, 1);
  aux01 = x_91;
  el02 = el01;
  x_92 = head->vptr->Insert(head, el01);
  head = x_92;
  x_93 = head->vptr->Print(head);
  aux01 = x_93;
  System_out_println (10000000);
  x_94 = ((struct Element*)(Tiger_new (&Element_vtable_, sizeof(struct Element))));
  el01 = x_94;
  x_95 = el01->vptr->Init(el01, 22, 34000, 0);
  aux01 = x_95;
  x_96 = head->vptr->Insert(head, el01);
  head = x_96;
  x_97 = head->vptr->Print(head);
  aux01 = x_97;
  x_98 = ((struct Element*)(Tiger_new (&Element_vtable_, sizeof(struct Element))));
  el03 = x_98;
  x_99 = el03->vptr->Init(el03, 27, 34000, 0);
  aux01 = x_99;
  x_100 = head->vptr->Search(head, el02);
  System_out_println (x_100);
  x_101 = head->vptr->Search(head, el03);
  System_out_println (x_101);
  System_out_println (10000000);
  x_102 = ((struct Element*)(Tiger_new (&Element_vtable_, sizeof(struct Element))));
  el01 = x_102;
  x_103 = el01->vptr->Init(el01, 28, 35000, 0);
  aux01 = x_103;
  x_104 = head->vptr->Insert(head, el01);
  head = x_104;
  x_105 = head->vptr->Print(head);
  aux01 = x_105;
  System_out_println (2220000);
  x_106 = head->vptr->Delete(head, el02);
  head = x_106;
  x_107 = head->vptr->Print(head);
  aux01 = x_107;
  System_out_println (33300000);
  x_108 = head->vptr->Delete(head, el01);
  head = x_108;
  x_109 = head->vptr->Print(head);
  aux01 = x_109;
  System_out_println (44440000);
  return 0;
}

// vtables
struct LinkedList_vtable LinkedList_vtable_ = 
{
};

struct Element_vtable Element_vtable_ = 
{
  Element_Init,
  Element_GetAge,
  Element_GetSalary,
  Element_GetMarried,
  Element_Equal,
  Element_Compare,
};

struct List_vtable List_vtable_ = 
{
  List_Init,
  List_InitNew,
  List_Insert,
  List_SetNext,
  List_Delete,
  List_Search,
  List_GetEnd,
  List_GetElem,
  List_GetNext,
  List_Print,
};

struct LL_vtable LL_vtable_ = 
{
  LL_Start,
};


// main method
int Tiger_main ()
{
  struct LL * x_0;
  int x_110;
  struct LL * x_111;

L_59:
  x_111 = ((struct LL*)(Tiger_new (&LL_vtable_, sizeof(struct LL))));
  x_110 = x_111->vptr->Start(x_111);
  System_out_println (x_110);
  return 0;
}




void *prev;
